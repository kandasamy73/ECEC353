/* A basic example of how function pointers work.
 *
 * This example consists of the following three files:
 *   -- function_pointers.c
 *   -- array_ops.c          (this file)
 *   -- array_ops.h
 * 
 *   Author: James A. Shackleford
 *     Date: January 19th, 2015
 *
 * This program demonstrates the use of function pointers in C.  Although not
 * strictly manditory to understand for this course, it does provide quite a
 * bit of insight as to the internal workings of functions such as
 * pthread_create().
 *
 * Compile using:
 *   gcc -c -o array_ops.o array_ops.c
 *   ar rcs libarray_ops.a array_ops.o
 */

#include <stdlib.h>
#include <limits.h>

struct table_entry
{
    int* ptr;
    int value;
    int index;
    int size;
};

/* This API tracks the largest value for every array it generates.
 * Unfortunately, the API is poorly written and can only track 100 items.
 * Using malloc() with realloc() could remove this limitation.  Another
 * options would be to use a linked list.
 */
static struct table_entry largest_number_table[100];

/* This function initializes the API.  This involves initializing the
 * largest number table */
void init_my_api()
{
    int i;

    for (i=0; i<100; i++) {
        largest_number_table[i].ptr = NULL;
    }
}

/* This API function accepts two equally sized arrays, their length, and a
 * function pointer to a function that describes the operation to perform on
 * the arrays.  The API function allocates memory for the resulting array that
 * is of equal size to the input arrays.
 */
int* my_api_create (int* array1, int* array2, int N, int(*func_ptr)(int a, int b))
{
    int i, entry, found;
    int* out;

    /* Find an empty table entry */
    found = 0;
    for (entry=0; entry<100; entry++) {
        if (largest_number_table[entry].ptr == NULL) {
            /* found an empty table entry */
            found = 1;
            break;
        }
    }

    /* If there are no available table entries, return a NULL pointer */
    if (!found) {
        return NULL;
    }

    /* Allocate memory for the result of the array operation */
    out = malloc(N*sizeof(int));

    /* Setup the table entry for this array */
    largest_number_table[entry].ptr = out;
    largest_number_table[entry].size = N;
    largest_number_table[entry].value = INT_MIN;

    /* Do the operation defined by func_ptr() */
    for (i=0; i<N; i++) {
        out[i] = func_ptr(array1[i], array2[i]);

        /* update table if result is the largest in the output array */
        if (out[i] > largest_number_table[entry].value) {
            largest_number_table[entry].value = out[i];
            largest_number_table[entry].index = i;
        }
    }

    /* Return address of output array */
    return out;
}


/* This function returns the index of the largest value for
 * the parameter array from the largest_number_table
 */
int my_api_get_largest_index (int* array)
{
    int i;

    for (i=0; i<100; i++) {
        if (largest_number_table[i].ptr == array) {
            return largest_number_table[i].index;
        }
    }

    /* ERROR, array not generated by our API */
    return -1;
}


/* This function:
 *   -- Remove the array from the largest_entry_table
 *   -- Populates the 2nd parameter with the largest value of the array
 *   -- Frees the memory used to store the array
 */
void my_api_reap (int* array, int* largest)
{
    int i;

    for (i=0; i<100; i++) {
        if (largest_number_table[i].ptr == array) {
            /* found this entry in the table */

            /* populate largest with the table entry */
            if (largest != NULL) {
                *largest = largest_number_table[i].value;
            }

            /* invalidate the table entry */
            largest_number_table[i].ptr = NULL;

            /* free the array */
            free(array);
        }
    }
}
