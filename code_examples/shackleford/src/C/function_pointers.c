/* A basic example of how function pointers work.
 * 
 *   Author: James A. Shackleford
 *     Date: January 19th, 2015
 *
 * This program demonstrates the use of function pointers in C.  Although not
 * strictly manditory to understand for this course, it does provide quite a
 * bit of insight as to the internal workings of functions such as
 * pthread_create().
 *
 * Compile using:
 *   gcc -o function_pointers function_pointers.c
 */

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

/*****************************************************************************
 * SOME BORING API I JUST MADE UP
 *    Normally, this would be compiled as a library you would link against.
 *****************************************************************************/
struct table_entry
{
    int* ptr;
    int value;
    int index;
    int size;
};

/* This API tracks the largest value for every array it generates.
 * Unfortunately, the API is poorly written and can only track 100 items.
 * Using malloc() with realloc() could remove this limitation.  Another
 * options would be to use a linked list.
 */
static struct table_entry largest_number_table[100];

/* This function initializes the API.  This involves initializing the
 * largest number table */
void init_my_api()
{
    int i;

    for (i=0; i<100; i++) {
        largest_number_table[i].ptr = NULL;
    }
}

/* This API function accepts two equally sized arrays, their length, and a
 * function pointer to a function that describes the operation to perform on
 * the arrays.  The API function allocates memory for the resulting array that
 * is of equal size to the input arrays.
 */
int* my_api_create (int* array1, int* array2, int N, int(*func_ptr)(int a, int b))
{
    int i, entry, found;
    int* out;

    /* Find an empty table entry */
    found = 0;
    for (entry=0; entry<100; entry++) {
        if (largest_number_table[entry].ptr == NULL) {
            /* found an empty table entry */
            found = 1;
            break;
        }
    }

    /* If there are no available table entries, return a NULL pointer */
    if (!found) {
        return NULL;
    }

    /* Allocate memory for the result of the array operation */
    out = malloc(N*sizeof(int));

    /* Setup the table entry for this array */
    largest_number_table[entry].ptr = out;
    largest_number_table[entry].size = N;
    largest_number_table[entry].value = INT_MIN;

    /* Do the operation defined by func_ptr() */
    for (i=0; i<N; i++) {
        out[i] = func_ptr(array1[i], array2[i]);

        /* update table if result is the largest in the output array */
        if (out[i] > largest_number_table[entry].value) {
            largest_number_table[entry].value = out[i];
            largest_number_table[entry].index = i;
        }
    }

    /* Return address of output array */
    return out;
}


/* This function returns the index of the largest value for
 * the parameter array from the largest_number_table
 */
int my_api_get_largest_index (int* array)
{
    int i;

    for (i=0; i<100; i++) {
        if (largest_number_table[i].ptr == array) {
            return largest_number_table[i].index;
        }
    }

    /* ERROR, array not generated by our API */
    return -1;
}


/* This function:
 *   -- Remove the array from the largest_entry_table
 *   -- Populates the 2nd parameter with the largest value of the array
 *   -- Frees the memory used to store the array
 */
void my_api_reap (int* array, int* largest)
{
    int i;

    for (i=0; i<100; i++) {
        if (largest_number_table[i].ptr == array) {
            /* found this entry in the table */

            /* populate largest with the table entry */
            if (largest != NULL) {
                *largest = largest_number_table[i].value;
            }

            /* invalidate the table entry */
            largest_number_table[i].ptr = NULL;

            /* free the array */
            free(array);
        }
    }
}
/*****************************************************************************
 * END API
 *****************************************************************************/




/*****************************************************************************
 * "USER" CODE EMPLOYING ABOVE API
 *****************************************************************************/

/*--------------------------------------------------------------------
 * Define some "callback functions" to pass as function pointers.
 *   These are our array operations.
 *--------------------------------------------------------------------*/
int add (int a, int b)
{
    return a + b;
}

int mul (int a, int b)
{
    return a * b;
}

int n_choose_k (int a, int b)
{
    /* here N = a and k = b */

    if (!b)
        return 1;

    return (a * n_choose_k(a-1, b-1)) / b;
}
/*--------------------------------------------------------------------*/


print_result(int* A, int* B, int N, int* C, char* op)
{
    int i;

    for (i=0; i<N; i++) {
        printf("%i %s %i = %i\n", A[i], op, B[i], C[i]);
    }
    printf("------------------------------\n");
}


int main(int argc, char *argv[])
{
    int A[] = {1, 2, 3, 4, 5, 6};
    int B[] = {6, 5, 4, 3, 2, 1};
    int N  = sizeof(A)/sizeof(int);
    int NB = sizeof(B)/sizeof(int);

    int* result_add;
    int* result_mul;
    int* result_nck;

    int largest_mul;
    int largest_nck;

    /* Arrays A and B must contain the same number of elements */
    if (N != NB) {
        fprintf(stderr, "error -- arrays A[] and B[] are different sizes\n");
        exit(EXIT_FAILURE);
    }

    /* Initialize our API */
    init_my_api();

    /* Use the API to generate some arrays using our callback functions */
    result_add = my_api_create(A, B, N, add);
    if (!result_add) {
        fprintf(stderr, "error -- my_api_create() failed\n");
        exit(EXIT_FAILURE);
    }
    result_mul = my_api_create(A, B, N, mul);
    if (!result_mul) {
        fprintf(stderr, "error -- my_api_create() failed\n");
        exit(EXIT_FAILURE);
    }
    result_nck = my_api_create(A, B, N, n_choose_k);
    if (!result_nck) {
        fprintf(stderr, "error -- my_api_create() failed\n");
        exit(EXIT_FAILURE);
    }
        
    /* Give some user feedback */
    print_result(A, B, N, result_add, "+");
    print_result(A, B, N, result_mul, "*");
    print_result(A, B, N, result_nck, "choose");

    /* Destroy the result arrays, reap their entries from the
     * largest_number_table, and store the largest values from
     * the table for our multiply and n choose k arrays
     * (don't store the largest value from addition array)
     */
    my_api_reap(result_add, NULL);
    my_api_reap(result_mul, &largest_mul);
    my_api_reap(result_nck, &largest_nck);

    printf ("Largest value from  \"multiply\"  array was: %i\n", largest_mul);
    printf ("Largest value from \"n choose k\" array was: %i\n", largest_nck);

    return 0;
}
